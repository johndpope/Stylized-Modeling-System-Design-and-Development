#define DLIB_JPEG_SUPPORT

#include <vector>

#include <Qdebug>
#include <QGuiApplication>
#include <QBuffer>
#include <QPixmap>
#include <QDir>
#include <QJsonDocument>
#include <QPainter>
#include <QElapsedTimer>

#include "mainwindow.h"
#include "plugin.h"

//using namespace dlib;
using namespace std;

//初始化static參數
QString Plugin::m_appFileDirectory = "";
QString Plugin::m_imagePath = "";
QList<double> Plugin::m_featurePos = QList<double>();
Rect Plugin::m_faceRect = Rect();

Plugin::Plugin(QObject *parent)
    : QObject(parent),
      clm(0),
      params(0)
{
    //取得app的根目錄路徑
    QDir dir = QDir::current();
    m_appFileDirectory = dir.absolutePath();
    qDebug() << dir.absolutePath();

    //將.obj檔存入手機根目錄中
    saveFile("boy13.obj");
    saveFile("boy15.obj");
    saveFile("boyWithoutEye.obj");
    saveFile("boytest.obj");
    saveFile("broom.obj");
    saveFile("chopper.obj");
    saveFile("cloth01.obj");
    saveFile("cloth02.obj");
    saveFile("gloves01.obj");
    saveFile("gloves02.obj");
    saveFile("hair01.obj");
    saveFile("hair02.obj");
    saveFile("hat01.obj");
    saveFile("hat02.obj");
    saveFile("ironman1.obj");
    saveFile("ironman2.obj");
    saveFile("ironman3.obj");
    saveFile("ironman4.obj");
    saveFile("luffy_cloth.obj");
    saveFile("luffy_hat.obj");
    saveFile("luffy_shorts.obj");
    saveFile("luffy_slippers.obj");
    saveFile("minion1.obj");
    saveFile("minion2.obj");
    saveFile("minion3.obj");
    saveFile("minion4.obj");
    saveFile("pants01.obj");
    saveFile("shoes01.obj");
    saveFile("shoes02.obj");
    saveFile("skateboard.obj");

    saveFile("haarcascade_frontalface_alt.xml");

    //saveFile(m_appFileDirectory+"/face_modelFiles/1000_943_test6.svm");

    //初始化json檔案
    m_faceFilter = parseJsonFile(":/jsonFiles/model_pca_20_svm.json");
    m_leftEyeFilter = parseJsonFile(":/jsonFiles/left_eye_filter.json");
    m_rightEyeFilter = parseJsonFile(":/jsonFiles/right_eye_filter.json");
    m_noseFilter = parseJsonFile(":/jsonFiles/nose_filter.json");

    clm = new Clm(params);
    clm->init(m_faceFilter, m_leftEyeFilter, m_rightEyeFilter, m_noseFilter);

    //face detection model file path
//    dlib::deserialize("/storage/sdcard1/Download/500_500.svm") >> detector;
//    dlib::deserialize("/storage/sdcard1/Download/800_1000.svm") >> detector;
//    dlib::deserialize("/storage/sdcard1/Download/200_original.svm") >> detector;
//    dlib::deserialize("/storage/sdcard1/Download/200_1000.svm") >> detector;
//    dlib::deserialize("/sdcard/Download/800_1000.svm") >> detector;
//    dlib::deserialize("/storage/sdcard1/Download/1000_943.svm") >> detector;
    dlib::deserialize("/storage/sdcard1/Download/1000_943_test4.svm") >> detector;
//    dlib::deserialize("/sdcard/Download/1000_943_test4.svm") >> detector;
//    dlib::deserialize("/storage/sdcard1/Download/1000_943_test6.svm") >> detector;

    //dlib::deserialize(m_appFileDirectory+"/face_modelFiles/1000_943_test6.svm") >> detector;

    //face landmark model file path
//    dlib::deserialize("/storage/sdcard1/Download/1000_830.dat") >> sp;
    dlib::deserialize("/storage/sdcard1/Download/1000_1000.dat") >> sp;
//    dlib::deserialize("/sdcard/Download/1000_830.dat") >> sp;
//      dlib::deserialize("/sdcard/Download/1000_1000.dat") >> sp;


    QFileInfo checkFile(m_appFileDirectory+"/face_modelFiles/1000_943_test6.svm");
        // check if file exists and if yes: Is it really a file and no directory?
        if (checkFile.exists() && checkFile.isFile()) {
            qDebug() << "svm file didn't exist!!";
        } else {
             qDebug() << "svm file exist!!";;
        }

   dlib::deserialize(m_appFileDirectory+"/face_modelFiles/1000_943_test6.svm") >> detector;

}

/*
 * FindFeatures
 *
 * 描述: 透過plugin的方式，呼叫Android專案中的函式，計算出人臉特徵點。
 *
 * 輸入: const QString &imagePath - 影像路徑
 * 輸出: 無
*/
void Plugin::findFeatures(const QString &imagePath)
{
    qDebug() << m_appFileDirectory;


    QElapsedTimer timer;
    timer.start();
    qDebug()<<"Timer start!!";
    qDebug() << "The start time:" << timer.elapsed() << "milliseconds";


    /*使用單張圖片的方式(需要修改三個參數)
     * 1. set std::string a in plugin.cpp
     *  example: std::string a = "/storage/sdcard1/Download/60.jpg";
     *
     * 2. change b_test parameter to "true" in main.qml
     *
     * 3. change photoPathTest parameter to file path in main.qml
     *  example: property string photoPathTest: "/storage/sdcard1/Download/39.jpg"
    */
//    std::string a = imagePath.toUtf8().constData();
    std::string a = "/storage/sdcard1/Download/71.jpg";
//    std::string a = "/sdcard/Download/39.jpg";
    std::string original = a;

    std::string i_5, i_6, i_7, i_8, i_9, i_10;

    QString b = QString::fromStdString(a);
    m_img = QImage(b, "JPEG");
//    m_img_5 = QImage(b, "JPEG");
//    m_img_6 = QImage(b, "JPEG");
//    m_img_7 = QImage(b, "JPEG");
//    m_img_8 = QImage(b, "JPEG");
//    m_img_9 = QImage(b, "JPEG");
//    m_img_10 = QImage(b, "JPEG");

    QPixmap pixmap;


    int w = m_img.width();
    int h = m_img.height();


    double scale = 1.0;
    double scale1 = 5.0, scale2 = 6.0, scale3 = 7.0, scale4 = 8.0, scale5 = 9.0, scale6 = 10.0;
    double scale_x = 0.0, scale_y = 0.0;

    qDebug()<<"Start image rotation";
    qDebug() << "Time: " << timer.elapsed() << "milliseconds";

    QString rotate_path;

    //圖片旋轉(如果寬大於高)
    if(w > h)
    {
        rotate_path = m_appFileDirectory + "/rotate.jpg";
        qDebug() << "totate!";
        QTransform transform;
        transform.rotate(-90);
        m_img = m_img.transformed(transform);

        m_img.save(rotate_path);
        m_img = QImage(rotate_path, "JPEG"); //這行可以拿掉，節省0.2s

        w = m_img.width();
        h = m_img.height();

        original = rotate_path.toUtf8().constData();

    }

    //cluster test(原本做群集的圖片大小為 640*640)
//    scale_x = w / 640.0;
//    scale_y = h / 640.0;


    qDebug()<<"Finish image rotation";
    qDebug() << "Time: " << timer.elapsed() << "milliseconds";


    //圖片縮放
    qDebug()<<"Start image scaling";
    qDebug() << "Time: " << timer.elapsed() << "milliseconds";

    if(w > 1000 || h > 1000){
        scale = 4.0;
    }
    else if(w > 600 || h > 600){
        scale = 2.0;
    }

    if(scale != 1.0){

//        m_img_5 = m_img.scaled(w/scale1,h/scale1,Qt::KeepAspectRatio);
//        m_img_5.save(m_appFileDirectory+"/scale_5.jpg");

//        m_img_6 = m_img.scaled(w/scale2,h/scale2,Qt::KeepAspectRatio);
//        m_img_6.save(m_appFileDirectory+"/scale_6.jpg");

//        m_img_7 = m_img.scaled(w/scale3,h/scale3,Qt::KeepAspectRatio);
//        m_img_7.save(m_appFileDirectory+"/scale_7.jpg");

//        m_img_8 = m_img.scaled(w/scale4,h/scale4,Qt::KeepAspectRatio);
//        m_img_8.save(m_appFileDirectory+"/scale_8.jpg");

//        m_img_9 = m_img.scaled(w/scale5,h/scale5,Qt::KeepAspectRatio);
//        m_img_9.save(m_appFileDirectory+"/scale_9.jpg");

//        m_img_10 = m_img.scaled(w/scale6,h/scale6,Qt::KeepAspectRatio);
//        m_img_10.save(m_appFileDirectory+"/scale_10.jpg");


        m_img = m_img.scaled(w/scale,h/scale,Qt::KeepAspectRatio);
        m_img.save(m_appFileDirectory+"/test.jpg");




        QString path  = m_appFileDirectory+"/test.jpg";
        a = path.toUtf8().constData();

//        path  = m_appFileDirectory+"/scale_5.jpg";
//        i_5 = path.toUtf8().constData();

//        path  = m_appFileDirectory+"/scale_6.jpg";
//        i_6 = path.toUtf8().constData();

//        path  = m_appFileDirectory+"/scale_7.jpg";
//        i_7 = path.toUtf8().constData();

//        path  = m_appFileDirectory+"/scale_8.jpg";
//        i_8 = path.toUtf8().constData();

//        path  = m_appFileDirectory+"/scale_9.jpg";
//        i_9 = path.toUtf8().constData();

//        path  = m_appFileDirectory+"/scale_10.jpg";
//        i_10 = path.toUtf8().constData();
    }


    qDebug()<<"Finish image scaling";
    qDebug() << "Time: " << timer.elapsed() << "milliseconds";

//    Mat mat = cv::imread(a);
//    Mat grayMat;
//    Mat crop;
    std::vector<Rect> faces;

    //std::string cascadeFilePath = (m_appFileDirectory+"/xmlFiles/haarcascade_frontalface_alt.xml").toStdString();

    //qDebug()<<"Start opencv face detection";
    //qDebug() << "Time: " << timer.elapsed() << "milliseconds";

    //確認opencv的cascadeClassifier初始化成功
//    if(!m_faceCascade.load(cascadeFilePath))
//    {
//        qDebug() << "Failed to load classifier";
//    }

//    //將原影像轉灰階
//    cvtColor(mat, grayMat, CV_RGB2GRAY);
//    equalizeHist(grayMat, grayMat);

//    //偵測人臉
//    m_faceCascade.detectMultiScale(grayMat, faces, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(100, 100));

//    if(faces.size() > 0){

//        qDebug() << "open cv detects face!!";

//         m_faceRect = faces[0];
//         for(size_t i=1; i<faces.size(); i++)
//         {
//             if(faces[i].width > m_faceRect.width)
//                 m_faceRect = faces[i];
//         }

//         qDebug() << "opencv detect x = " << m_faceRect.x;
//         qDebug() << "opencv detect y = " << m_faceRect.y;
//         qDebug() << "opencv detect width = " << m_faceRect.width;
//         qDebug() << "opencv detect height = " << m_faceRect.height;

//         //這邊是把cv::Rect得資料轉成dlib::rectangle
//         //qDebug() << "set left";
//         m_faceRect_dlib.set_left((long)m_faceRect.x - 10);
//         //qDebug() << "set top";
//         m_faceRect_dlib.set_top((long)m_faceRect.y);
//         //qDebug() << "set right";
//         m_faceRect_dlib.set_right((long)m_faceRect.x - 10 +
//                                   (long)m_faceRect.width + 5);
//         //qDebug() << "set bottom";
//         m_faceRect_dlib.set_bottom((long)m_faceRect.y +
//                                    (long)m_faceRect.height + 20);

//    }

//    qDebug()<<"finishing opencv face detection";
//    qDebug() << "Time: " << timer.elapsed() << "milliseconds";

    std::vector<dlib::rectangle> dets, dets_5, dets_6, dets_7, dets_8, dets_9, dets_10;
    dlib::rectangle m_faceRect_dlib;
    dlib::rectangle original_dlib, original_dlib_5, original_dlib_6,
            original_dlib_7, original_dlib_8, original_dlib_9, original_dlib_10;

    dlib::array2d<dlib::rgb_pixel> img, img5, img6, img7, img8, img9, img10, img_original;
    dlib::load_image(img, a);
    dlib::load_image(img_original, original);


//    dlib::load_image(img5, i_5);  //測試用
//    dlib::load_image(img6, i_6);
//    dlib::load_image(img7, i_7);
//    dlib::load_image(img8, i_8);
//    dlib::load_image(img9, i_9);
//    dlib::load_image(img10, i_10);


    qDebug()<<"load image";
    qDebug() << "Time: " << timer.elapsed() << "milliseconds";


    //start dlib face detection
    dets = detector(img);
    if(dets.size() > 0){

        qDebug()<<"dlib detect scale 4.0 face";

        original_dlib.set_left(dets[0].left() * scale);
        original_dlib.set_top(dets[0].top() * scale);
        original_dlib.set_right((dets[0].left()+
                                           dets[0].width()) * scale);
        original_dlib.set_bottom((dets[0].top() +
                                           dets[0].height()) * scale);
    }

    /*測試用*/
//    dets_5 = detector(img5);
//    if(dets_5.size() > 0){

//        qDebug()<<"dlib detect scale 5.0 face";

//        original_dlib_5.set_left(dets_5[0].left() * scale1);
//        original_dlib_5.set_top(dets_5[0].top() * scale1);
//        original_dlib_5.set_right((dets_5[0].left()+
//                                           dets_5[0].width()) * scale1);
//        original_dlib_5.set_bottom((dets_5[0].top() +
//                                           dets_5[0].height()) * scale1);
//    }

//    dets_6 = detector(img6);
//    if(dets_6.size() > 0){

//        qDebug()<<"dlib detect scale 6.0 face";

//        original_dlib_6.set_left(dets_6[0].left() * scale2);
//        original_dlib_6.set_top(dets_6[0].top() * scale2);
//        original_dlib_6.set_right((dets_6[0].left()+
//                                           dets_6[0].width()) * scale2);
//        original_dlib_6.set_bottom((dets_6[0].top() +
//                                           dets_6[0].height()) * scale2);
//    }

//    dets_7 = detector(img7);
//    if(dets_7.size() > 0){

//        qDebug()<<"dlib detect scale 7.0 face";

//        original_dlib_7.set_left(dets_7[0].left() * scale3);
//        original_dlib_7.set_top(dets_7[0].top() * scale3);
//        original_dlib_7.set_right((dets_7[0].left()+
//                                           dets_7[0].width()) * scale3);
//        original_dlib_7.set_bottom((dets_7[0].top() +
//                                           dets_7[0].height()) * scale3);
//    }

//    dets_8 = detector(img8);
//    if(dets_8.size() > 0){

//        qDebug()<<"dlib detect scale 8.0 face";

//        original_dlib_8.set_left(dets_8[0].left() * scale4);
//        original_dlib_8.set_top(dets_8[0].top() * scale4);
//        original_dlib_8.set_right((dets_8[0].left()+
//                                           dets_8[0].width()) * scale4);
//        original_dlib_8.set_bottom((dets_8[0].top() +
//                                           dets_8[0].height()) * scale4);
//    }

//    dets_9 = detector(img9);
//    if(dets_9.size() > 0){

//        qDebug()<<"dlib detect scale 9.0 face";

//        original_dlib_9.set_left(dets_9[0].left() * scale5);
//        original_dlib_9.set_top(dets_9[0].top() * scale5);
//        original_dlib_9.set_right((dets_9[0].left()+
//                                           dets_9[0].width()) * scale5);
//        original_dlib_9.set_bottom((dets_9[0].top() +
//                                           dets_9[0].height()) * scale5);
//    }

//    dets_10 = detector(img10);
//    if(dets_10.size() > 0){

//        qDebug()<<"dlib detect scale 10.0 face";

//        original_dlib_10.set_left(dets_10[0].left() * scale6);
//        original_dlib_10.set_top(dets_10[0].top() * scale6);
//        original_dlib_10.set_right((dets_10[0].left()+
//                                           dets_10[0].width()) * scale6);
//        original_dlib_10.set_bottom((dets_10[0].top() +
//                                           dets_10[0].height()) * scale6);
//    }


    /******/



    qDebug()<<"finishing dlib face detection";
    qDebug() << "Time: " << timer.elapsed() << "milliseconds";


    std::vector<dlib::full_object_detection> shapes, shapes_5, shapes_6, shapes_7,
                                            shapes_8, shapes_9, shapes_10;
    m_featurePos.clear();

    /*use for test*/
//        faces.clear();
//        dets.clear();
//        scale_x = (double)original_dlib.width() / 150.0;
//        scale_y = (double)original_dlib.height() / 150.0;

//        m_featurePos.push_back(((double)original_dlib.left()));
//        m_featurePos.push_back(((double)original_dlib.top()));
//        m_featurePos.push_back((double)(original_dlib.left() + original_dlib.width()));
//        m_featurePos.push_back((double)(original_dlib.top() + original_dlib.height()));
     /************/

    //如果這兩種臉部偵測其中一個有偵測到就會進入以下的程式碼
    if(faces.size() > 0 || dets.size() > 0){
        dlib::full_object_detection shape;

        if(faces.size() > 0 && dets.size() > 0){

            qDebug()<<"both two method detect face!";

            //如果兩種臉部偵測都有偵測到，則一律採用dlib的臉部偵測結果
            shape = sp(img_original, original_dlib);

            //放入face detection的框框資訊(左上角和右下角)
//            m_featurePos.push_back(((double)original_dlib.left())*scale);
//            m_featurePos.push_back(((double)original_dlib.top())*scale);
//            m_featurePos.push_back((double)(original_dlib.left() + original_dlib.width())*scale);
//            m_featurePos.push_back((double)(original_dlib.top() + original_dlib.height())*scale);

            m_featurePos.push_back(((double)original_dlib.left()));
            m_featurePos.push_back(((double)original_dlib.top()));
            m_featurePos.push_back((double)(original_dlib.left() + original_dlib.width()));
            m_featurePos.push_back((double)(original_dlib.top() + original_dlib.height()));

        }
        else if(faces.size() > 0 && dets.size() == 0 ){

//            qDebug()<<"only opencv detect face!";

//            shape = sp(img, m_faceRect_dlib);

//            //放入face detection的框框資訊(左上角和右下角)
//            m_featurePos.push_back(((double)m_faceRect.x - 10)*scale);
//            m_featurePos.push_back(((double)m_faceRect.y)*scale);
//            m_featurePos.push_back((double)(m_faceRect.x - 10 + m_faceRect.width + 5)*scale);
//            m_featurePos.push_back((double)(m_faceRect.y + m_faceRect.height + 20)*scale);


        }
        else{

            qDebug()<<"only dlib detect face!";

            shape = sp(img_original, original_dlib);

            //放入face detection的框框資訊(左上角和右下角)
            m_featurePos.push_back(((double)original_dlib.left()));
            m_featurePos.push_back(((double)original_dlib.top()));
            m_featurePos.push_back((double)(original_dlib.left() + original_dlib.width()));
            m_featurePos.push_back((double)(original_dlib.top() + original_dlib.height()));

        }

        shapes.push_back(shape);

        qDebug()<<"fitting end";
        qDebug() << "The fitting took" << timer.elapsed() << "milliseconds";



        qDebug()<<"get shapes";
        const dlib::full_object_detection& d = shapes[0];


        qDebug()<<"start to get landmarks";
        for(unsigned long i = 0 ; i < 68 ; i++){
            dlib::point a = d.part(i);
//            m_featurePos.push_back((double)a.x()*scale);
//            m_featurePos.push_back((double)a.y()*scale);
            m_featurePos.push_back((double)a.x());
            m_featurePos.push_back((double)a.y());
        }


        qDebug()<<"geting landmark end";
        qDebug() << "Time" << timer.elapsed() << "milliseconds";
    }
    else{
        //<如果都沒有偵測到，則採用測試用的landmark(這部分可以拿掉)

        qDebug()<<"Didn't detect any face!!";

        /*
        double pos[] = {570.613, 1044.9,
                        566.996, 1154.17,
                        590.249, 1279.06,
                        625.843, 1393.81,
                        680.142, 1469.43,
                        748.102, 1538.9,
                        821.147, 1579.37,
                        917.913, 1612.73,
                        1016.34, 1601.73,
                        1091.38, 1545.47,
                        1150.72, 1479.13,
                        1211.3, 1391.4,
                        1239.44, 1287.25,
                        1260.19, 1167.59,
                        1242.62, 1051.67,
                        1207.16, 979.359,
                        1152.79, 953.607,
                        1071.06, 954.986,
                        1005.36, 967.787,
                        646.446, 986.576,
                        701.995, 958.71,
                        785.015, 958.844,
                        851.354, 970.407,
                        695.442, 1060.86,
                        762.016, 1030.47,
                        831.739, 1061.45,
                        761.925, 1078.05,
                        764.919, 1052.53,
                        1159.96, 1057.15,
                        1095.47, 1027.06,
                        1024.35, 1059.23,
                        1095.76, 1075.26,
                        1095.14, 1049.36,
                        926.643, 1035.63,
                        846.226, 1197.25,
                        816.189, 1250.32,
                        844.54, 1287.81,
                        923.205, 1301.29,
                        1002.7, 1287.33,
                        1030.73, 1250.9,
                        1000.92, 1197.25,
                        924.589, 1142.03,
                        867.101, 1267.19,
                        978.791, 1266.53,
                        781.328, 1413.28,
                        830.316, 1383.29,
                        883.892, 1371.98,
                        921.481, 1379.53,
                        958.83, 1371.89,
                        1011.89, 1382.76,
                        1060.45, 1412.51,
                        1024.72, 1447.3,
                        979.866, 1469.05,
                        919.928, 1476.21,
                        860.431, 1470.09,
                        814.871, 1448.01,
                        851.222, 1424.08,
                        920.017, 1430.29,
                        989.613, 1422.96,
                        990.293, 1402.93,
                        920.629, 1405.27,
                        852.352, 1403.29,
                        923.259, 1242.78,
                        723.668, 1039.43,
                        802.767, 1038.03,
                        798.503, 1071.92,
                        725.562, 1072.98,
                        1133.45, 1035.65,
                        1054.07, 1035.52,
                        1058.52, 1069.49,
                        1131.11, 1069.52};*/


        double pos[] = {22.5262, 17.2902, 16.1673, 32.8096, 11.7422, 49.8363, 9.06008, 66.8165, 9.33951,
                        83.3056, 13.1294, 99.9348, 19.3612, 114.405, 27.8027, 128.007, 40.7254, 138.434
                       , 58.7059, 140.2, 74.3622, 134.659, 88.67, 127.088, 102.384, 117.401, 114.1,
                        105.298, 123.838, 92.7022, 131.189, 78.8582, 136.354, 63.6217, 46.5019, 8.9195,
                        56.2755, 8.82938, 65.348, 11.2765, 72.7444, 16.2146, 79.3673, 22.9861, 110.832,
                        39.404, 118.539, 39.8532, 125.937, 41.3713, 131.624, 45.1965, 136.172, 51.4572,
                        90.0283, 46.0542, 85.7179, 57.9604, 81.6089, 69.2864, 77.478, 80.1992, 59.0042,
                        80.4106, 64.9152, 83.2861, 70.7766, 90.5392, 80.1713, 90.3775, 85.5228, 92.4333,
                        46.2903, 27.0827, 56.4088, 26.6626, 65.412, 31.0112, 70.5659, 40.6552, 61.4819,
                        39.2934, 52.7935, 34.8558, 102.3, 56.2226, 110.711, 53.9524, 119.225, 56.9677,
                        124.089, 64.2302, 117.092, 65.1038, 108.633, 61.9697, 39.3901, 93.0904, 49.2656,
                        94.737, 58.2856, 97.1862, 63.6205, 101.958, 70.8258, 102.744, 76.9691, 107.032,
                        82.886, 111.833, 74.2332, 116.725, 65.3696, 118.732, 55.5306, 117.352, 47.9937,
                        111.653, 42.5525, 103.786, 46.9711, 99.9424, 54.3796, 101.973, 60.7921, 104.942,
                        67.317, 107.592, 72.8561, 111.06, 65.6111, 111.859, 59.2314, 110.08, 53.4644,
                        106.569};


          //cluster test
          for(int i = 0 ; i < 136 ; i++){
              if((i%2) == 1)
                  pos[i] = pos[i]*scale_y + (double)original_dlib.top();
              else
                  pos[i] = pos[i]*scale_x + (double)original_dlib.left();
          }


          for(int i=0; i<142; i++)
          {
              m_featurePos.push_back(pos[i]);
          }


    }

//    if(dets_5.size() > 0){
//        qDebug()<<"add 縮小五倍結果";

//        dlib::full_object_detection shape;
//        shape = sp(img_original, original_dlib_5);
//        shapes_5.push_back(shape);


//        const dlib::full_object_detection& d = shapes_5[0];
//        for(unsigned long i = 0 ; i < 68 ; i++){
//            dlib::point a = d.part(i);
//            m_featurePos.push_back((double)a.x());
//            m_featurePos.push_back((double)a.y());
//        }



//        m_featurePos.push_back(((double)original_dlib_5.left()));
//        m_featurePos.push_back(((double)original_dlib_5.top()));
//        m_featurePos.push_back((double)(original_dlib_5.left() + original_dlib_5.width()));
//        m_featurePos.push_back((double)(original_dlib_5.top() + original_dlib_5.height()));

//    }
//    if(dets_6.size() > 0){
//        qDebug()<<"add 縮小六倍結果";

//        dlib::full_object_detection shape;
//        shape = sp(img_original, original_dlib_6);
//        shapes_6.push_back(shape);

//        const dlib::full_object_detection& d = shapes_6[0];
//        for(unsigned long i = 0 ; i < 68 ; i++){
//            dlib::point a = d.part(i);
//            m_featurePos.push_back((double)a.x());
//            m_featurePos.push_back((double)a.y());
//        }

//        m_featurePos.push_back(((double)original_dlib_6.left()));
//        m_featurePos.push_back(((double)original_dlib_6.top()));
//        m_featurePos.push_back((double)(original_dlib_6.left() + original_dlib_6.width()));
//        m_featurePos.push_back((double)(original_dlib_6.top() + original_dlib_6.height()));
//    }
//    if(dets_7.size() > 0){
//        qDebug()<<"add 縮小七倍結果";

//        dlib::full_object_detection shape;
//        shape = sp(img_original, original_dlib_7);
//        shapes_7.push_back(shape);

//        const dlib::full_object_detection& d = shapes_7[0];
//        for(unsigned long i = 0 ; i < 68 ; i++){
//            dlib::point a = d.part(i);
//            m_featurePos.push_back((double)a.x());
//            m_featurePos.push_back((double)a.y());
//        }

//        m_featurePos.push_back(((double)original_dlib_7.left()));
//        m_featurePos.push_back(((double)original_dlib_7.top()));
//        m_featurePos.push_back((double)(original_dlib_7.left() + original_dlib_7.width()));
//        m_featurePos.push_back((double)(original_dlib_7.top() + original_dlib_7.height()));
//    }
//    if(dets_8.size() > 0){
//        qDebug()<<"add 縮小八倍結果";

//        dlib::full_object_detection shape;
//        shape = sp(img_original, original_dlib_8);
//        shapes_8.push_back(shape);

//        const dlib::full_object_detection& d = shapes_8[0];
//        for(unsigned long i = 0 ; i < 68 ; i++){
//            dlib::point a = d.part(i);
//            m_featurePos.push_back((double)a.x());
//            m_featurePos.push_back((double)a.y());
//        }

//        m_featurePos.push_back(((double)original_dlib_8.left()));
//        m_featurePos.push_back(((double)original_dlib_8.top()));
//        m_featurePos.push_back((double)(original_dlib_8.left() + original_dlib_8.width()));
//        m_featurePos.push_back((double)(original_dlib_8.top() + original_dlib_8.height()));
//    }
//    if(dets_9.size() > 0){
//        qDebug()<<"add 縮小九倍結果";

//        dlib::full_object_detection shape;
//        shape = sp(img_original, original_dlib_9);
//        shapes_9.push_back(shape);

//        const dlib::full_object_detection& d = shapes_9[0];
//        for(unsigned long i = 0 ; i < 68 ; i++){
//            dlib::point a = d.part(i);
//            m_featurePos.push_back((double)a.x());
//            m_featurePos.push_back((double)a.y());
//        }

//        m_featurePos.push_back(((double)original_dlib_9.left()));
//        m_featurePos.push_back(((double)original_dlib_9.top()));
//        m_featurePos.push_back((double)(original_dlib_9.left() + original_dlib_9.width()));
//        m_featurePos.push_back((double)(original_dlib_9.top() + original_dlib_9.height()));
//    }
//    if(dets_10.size() > 0){
//        qDebug()<<"add 縮小十倍結果";

//        dlib::full_object_detection shape;
//        shape = sp(img_original, original_dlib_10);
//        shapes_10.push_back(shape);

//        const dlib::full_object_detection& d = shapes_10[0];
//        for(unsigned long i = 0 ; i < 68 ; i++){
//            dlib::point a = d.part(i);
//            m_featurePos.push_back((double)a.x());
//            m_featurePos.push_back((double)a.y());
//        }

//        m_featurePos.push_back(((double)original_dlib_10.left()));
//        m_featurePos.push_back(((double)original_dlib_10.top()));
//        m_featurePos.push_back((double)(original_dlib_10.left() + original_dlib_10.width()));
//        m_featurePos.push_back((double)(original_dlib_10.top() + original_dlib_10.height()));
//    }



//    if(dets_test.size() > 0){

//         qDebug()<<"dlib method detect face in test image!";

//         dlib::full_object_detection shape;
//         shape = sp(img, original_dlib);
//         shapes_test.push_back(shape);

//         const dlib::full_object_detection& d = shapes_test[0];

//         for(unsigned long i = 0 ; i < 68 ; i++){
//             dlib::point a = d.part(i);
//             m_featurePos.push_back((double)a.x()*scale1); //scale1依據測試的實驗而改變
//             m_featurePos.push_back((double)a.y()*scale1);
//         }
//    }




}

/*
 * GetFeaturePos
 *
 * 描述: 取得71個特徵點座標
 *
 * 輸入: 無
 * 輸出: QList<double> - 特徵點座標
*/
QList<double> Plugin::getFeaturePos()
{
    return m_featurePos;
}

/*
 * SetFeaturePos
 *
 * 描述: 設定特徵點座標
 *
 * 輸入: int idx - 第幾個特徵點
 *      double x, double y - 特徵點座標
 * 輸出: 無
*/
void Plugin::setFeaturePos(int idx, double x, double y)
{
    if(m_featurePos[0] != -1)
    {
        m_featurePos[idx] = x;
        m_featurePos[idx+1] = y;
    }
}

/*
 * SetFaceRect
 *
 * 描述: 設定人臉的偵測框
 *
 * 輸入: int x, int y - 偵測框的起始點座標
 *      int width - 偵測框的寬
 *      int height - 偵測框的長
 * 輸出: 無
*/
void Plugin::setFaceRect(int x, int y, int width, int height)
{
    QImage tmp = m_img.copy(x, y, width, height);
    tmp.save(m_appFileDirectory+"/face.jpg");

    float scale = 500.0f/m_img.height();

    QVector<double> box = QVector<double>(4);
    box[0] = x*scale;
    box[1] = y*scale;
    box[2] = width*scale;
    box[3] = height*scale;

    m_img.save(m_appFileDirectory+"/element.jpg");
    clm->setRootDirectory(m_appFileDirectory);
    clm->start(m_img, box);

    QVector<QVector<double>> pos = clm->getCurrentPosition();
    m_featurePos.clear();
    for(int i=0; i<pos.length(); i++)
    {
        m_featurePos.push_back(pos[i][0]/scale);
        m_featurePos.push_back(pos[i][1]/scale);
    }
}

/*
 * SaveFile
 *
 * 描述: 存檔
 *
 * 輸入: QString fileName - 檔名
 * 輸出: 無
*/
void Plugin::saveFile(QString fileName)
{
    // 存檔
    QDir dir(m_appFileDirectory+"/");
    if(fileName.contains(".xml"))
    {
        if(!QFile::exists(m_appFileDirectory+"/xmlFiles"))
            dir.mkdir("xmlFiles");

        QFile in(":/xmlFiles/"+fileName);
        in.open(QIODevice::ReadOnly);

        QFile out(m_appFileDirectory+"/xmlFiles/"+fileName);
        out.open(QIODevice::WriteOnly);

        out.write(in.readAll());
        in.close();
        out.close();
    }
    else if(fileName.contains(".obj") || fileName.contains(".mtl"))
    {
        if(!QFile::exists(m_appFileDirectory+"/modelFiles"))
            dir.mkdir("modelFiles");

        QFile in(":modelFiles/"+fileName);
        in.open(QIODevice::ReadOnly);

        QFile out(m_appFileDirectory+"/modelFiles/"+fileName);
        out.open(QIODevice::WriteOnly);

        out.write(in.readAll());
        in.close();
        out.close();
    }
}

/*
 * SwitchToDeformWindow
 *
 * 描述: 切換到變形介面
 *
 * 輸入: 無
 * 輸出: 無
*/
void Plugin::switchToDeformWindow()
{
    createFaceTexture(m_img);
    MainWindow *window = new MainWindow();
    window->show();
}

QJsonObject Plugin::parseJsonFile(QString fileName)
{
    qDebug() << "jsonFileName = " << fileName;
    QFile in(fileName);
    in.open(QIODevice::ReadOnly);

    QString value = (QString) in.readAll();
    QJsonDocument document = QJsonDocument::fromJson(value.toUtf8());

    return document.object();
}

void Plugin::createFaceTexture(QImage pSrc)
{
    //Original picture do equalizeHist
//    Mat newImg(pSrc.height(), pSrc.width(), CV_8UC3, (uchar*)pSrc.bits(), pSrc.bytesPerLine());
//    Mat ycrcb;
//    cvtColor(newImg,ycrcb,CV_BGR2YCrCb);
//    vector<Mat> channels;
//    split(ycrcb,channels);
//    equalizeHist(channels[0], channels[0]);
//    Mat result;
//    merge(channels,ycrcb);
//    cvtColor(ycrcb,result,CV_YCrCb2BGR);

//    QImage QnewImg= QImage(result.data, result.cols, result.rows, result.step, QImage::Format_RGB888);
//    QImage imgSrc = QnewImg.copy(m_faceRect.x, m_faceRect.y, m_faceRect.width, m_faceRect.height);
//    QImage imgMask = QImage(m_faceRect.width, m_faceRect.height, QImage::Format_RGB888);

    QImage imgSrc = pSrc.copy(m_faceRect.x, m_faceRect.y, m_faceRect.width, m_faceRect.height);
    QImage imgMask = QImage(m_faceRect.width, m_faceRect.height, QImage::Format_RGB888);

    // Create the mask
    // Region of left eye
    int tmpStartX = m_featurePos[38] - m_faceRect.x;
    int tmpEndX = m_featurePos[44] - m_faceRect.x;
    int tmpStartY = (m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y;
    int tmpEndY = (m_featurePos[53]+m_featurePos[83])/2.0 - m_faceRect.y;
    for(int i=tmpStartX; i<tmpEndX; i++)
        for(int j=tmpStartY; j<tmpEndY; j++)
            imgMask.setPixel(i, j, qRgb(255, 255, 255));

    // Region of right eye
    tmpStartX = m_featurePos[36] - m_faceRect.x;
    tmpEndX = m_featurePos[30] - m_faceRect.x;
    tmpStartY = (m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y;
    tmpEndY = (m_featurePos[53]+m_featurePos[83])/2.0 - m_faceRect.y;
    for(int i=tmpStartX; i<tmpEndX; i++)
        for(int j=tmpStartY; j<tmpEndY; j++)
            imgMask.setPixel(i, j, qRgb(255, 255, 255));

    // Region of nose
    tmpStartX = m_featurePos[88] - m_faceRect.x;
    tmpEndX = m_featurePos[100] - m_faceRect.x;
    tmpStartY = (m_featurePos[83]+m_featurePos[69])/2.0 - m_faceRect.y;
    tmpEndY = (m_featurePos[75]+m_featurePos[95])/2.0 - m_faceRect.y;
    for(int i=tmpStartX; i<tmpEndX; i++)
        for(int j=tmpStartY; j<tmpEndY; j++)
            imgMask.setPixel(i, j, qRgb(255, 255, 255));

    // Region of mouth
    tmpStartX = m_featurePos[52] - m_faceRect.x;
    tmpEndX = m_featurePos[62] - m_faceRect.x;
    tmpStartY = (m_featurePos[75]+m_featurePos[95])/2.0 - m_faceRect.y;
    tmpEndY = m_featurePos[107] - m_faceRect.y;
    for(int i=tmpStartX; i<tmpEndX; i++)
        for(int j=tmpStartY; j<tmpEndY; j++)
            imgMask.setPixel(i, j, qRgb(255, 255, 255));

    // Scale the image to 400x400
    QTransform transform;
    float s = 400.0f / imgSrc.width();
    transform.scale(s, s);
    imgSrc = imgSrc.transformed(transform);
    imgMask = imgMask.transformed(transform);

    // Save image
    imgSrc.save(m_appFileDirectory+"/src.png");
    imgMask.save(m_appFileDirectory+"/mask.png");

    QImage imgTarget(":/textureFiles/target.png");

    // Convert the image format
    imgSrc = imgSrc.convertToFormat(QImage::Format_RGB888);
    imgTarget = imgTarget.convertToFormat(QImage::Format_RGB888);
    imgMask = imgMask.convertToFormat(QImage::Format_Indexed8);

    Mat matSrc(imgSrc.height(), imgSrc.width(), CV_8UC3, (uchar*)imgSrc.bits(), imgSrc.bytesPerLine());
    Mat matTarget(imgTarget.height(), imgTarget.width(), CV_8UC3, (uchar*)imgTarget.bits(), imgTarget.bytesPerLine());
    Mat matMask(imgMask.height(), imgMask.width(), CV_8UC1, (uchar*)imgMask.bits(), imgMask.bytesPerLine());

    //調整target影像的顏色與相機影像的histogram相似
    PoissonBlender pb = PoissonBlender(matSrc, matTarget, matMask);

    cv::Mat dst_img;
    pb.seamlessClone(dst_img, 314, 56, true);

    Rect region;
    // Blur the region of left eye
    tmpStartX = (m_featurePos[38] - m_faceRect.x) * s + 312;
    tmpEndX = (m_featurePos[44]- m_faceRect.x) * s + 312;
    tmpStartY = ((m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y) * s + 56 - 20;
    tmpEndY = ((m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y) * s + 56 + 20;
    region = Rect(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    blur(dst_img(region), dst_img(region), Size(7, 7));

    tmpStartX = (m_featurePos[44] - m_faceRect.x) * s + 312 - 20;
    tmpEndX = (m_featurePos[44]- m_faceRect.x) * s + 312 + 20;
    tmpStartY = ((m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y) * s + 56;;
    tmpEndY = ((m_featurePos[53]+m_featurePos[83])/2.0 - m_faceRect.y) * s + 56;
    region = Rect(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    blur(dst_img(region), dst_img(region), Size(3, 3));

    tmpStartX = (m_featurePos[38] - m_faceRect.x) * s + 312;
    tmpEndX = (m_featurePos[44]- m_faceRect.x) * s + 312;
    tmpStartY = ((m_featurePos[53]+m_featurePos[83])/2.0 - m_faceRect.y) * s + 56 - 20;
    tmpEndY = ((m_featurePos[53]+m_featurePos[83])/2.0 - m_faceRect.y) * s + 56 + 20;
    region = Rect(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    blur(dst_img(region), dst_img(region), Size(7, 7));

    tmpStartX = (m_featurePos[38] - m_faceRect.x) * s + 312 - 20;
    tmpEndX = (m_featurePos[38] - m_faceRect.x) * s + 312 + 20;
    tmpStartY = ((m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y) * s + 56;
    tmpEndY = ((m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y) * s + 56;
    region = Rect(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    blur(dst_img(region), dst_img(region), Size(3, 3));

    // Blur the region of right eye
    tmpStartX = (m_featurePos[36] - m_faceRect.x) * s + 312;
    tmpEndX = (m_featurePos[30]- m_faceRect.x) * s + 312;
    tmpStartY = ((m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y) * s + 56 - 20;
    tmpEndY = ((m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y) * s + 56 + 20;
    region = Rect(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    blur(dst_img(region), dst_img(region), Size(7, 7));

    tmpStartX = (m_featurePos[30] - m_faceRect.x) * s + 312 - 20;
    tmpEndX = (m_featurePos[30]- m_faceRect.x) * s + 312 + 20;
    tmpStartY = ((m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y) * s + 56;
    tmpEndY = ((m_featurePos[53]+m_featurePos[83])/2.0 - m_faceRect.y) * s + 56;
    region = Rect(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    blur(dst_img(region), dst_img(region), Size(3, 3));

    tmpStartX = (m_featurePos[36] - m_faceRect.x) * s + 312;
    tmpEndX = (m_featurePos[30]- m_faceRect.x) * s + 312;
    tmpStartY = ((m_featurePos[53]+m_featurePos[83])/2.0 - m_faceRect.y) * s + 56 - 20;
    tmpEndY = ((m_featurePos[53]+m_featurePos[83])/2.0 - m_faceRect.y) * s + 56 + 20;
    region = Rect(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    blur(dst_img(region), dst_img(region), Size(7, 7));

    tmpStartX = (m_featurePos[36] - m_faceRect.x) * s + 312 - 20;
    tmpEndX = (m_featurePos[36] - m_faceRect.x) * s + 312 + 20;
    tmpStartY = ((m_featurePos[45]+m_featurePos[49])/2.0 - m_faceRect.y) * s + 56;
    tmpEndY = ((m_featurePos[53]+m_featurePos[83])/2.0 - m_faceRect.y) * s + 56;
    region = Rect(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    blur(dst_img(region), dst_img(region), Size(3, 3));

    // Blur the region of nose
    tmpStartX = (m_featurePos[88] - m_faceRect.x) * s + 312 - 20;
    tmpEndX = (m_featurePos[88] - m_faceRect.x) * s + 312 + 20;
    tmpStartY = ((m_featurePos[83]+m_featurePos[69])/2.0 - m_faceRect.y) * s + 56;
    tmpEndY = ((m_featurePos[75]+m_featurePos[95])/2.0 - m_faceRect.y) * s + 56;
    region = Rect(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    blur(dst_img(region), dst_img(region), Size(7, 7));

    tmpStartX = (m_featurePos[100] - m_faceRect.x) * s + 312 - 20;
    tmpEndX = (m_featurePos[100] - m_faceRect.x) * s + 312 + 20;
    tmpStartY = ((m_featurePos[83]+m_featurePos[69])/2.0 - m_faceRect.y) * s + 56;
    tmpEndY = ((m_featurePos[75]+m_featurePos[95])/2.0 - m_faceRect.y) * s + 56;
    region = Rect(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    blur(dst_img(region), dst_img(region), Size(7, 7));


    QImage testImg = QImage(dst_img.data, dst_img.cols, dst_img.rows, dst_img.step, QImage::Format_RGB888).copy();
    qDebug() << testImg.save(m_appFileDirectory+"/result.png");
    tmpStartX = (m_featurePos[2] - m_faceRect.x) * s + 312;
    tmpEndX = (m_featurePos[26]- m_faceRect.x) * s + 312;
    tmpStartY = (m_featurePos[41] - m_faceRect.y) * s + 56;
    tmpEndY = (m_featurePos[15] - m_faceRect.y) * s + 56;
    QImage afterBlendingImg = testImg.copy(tmpStartX, tmpStartY, tmpEndX-tmpStartX, tmpEndY-tmpStartY);
    qDebug() << afterBlendingImg.save(m_appFileDirectory+"/afterBlending.png");
}

void Plugin::checkImage(QImage pSrc)
{

}

void Plugin::test_SetFeaturePos()
{
    double pos[] = {570.613, 1044.9,
                    566.996, 1154.17,
                    590.249, 1279.06,
                    625.843, 1393.81,
                    680.142, 1469.43,
                    748.102, 1538.9,
                    821.147, 1579.37,
                    917.913, 1612.73,
                    1016.34, 1601.73,
                    1091.38, 1545.47,
                    1150.72, 1479.13,
                    1211.3, 1391.4,
                    1239.44, 1287.25,
                    1260.19, 1167.59,
                    1242.62, 1051.67,
                    1207.16, 979.359,
                    1152.79, 953.607,
                    1071.06, 954.986,
                    1005.36, 967.787,
                    646.446, 986.576,
                    701.995, 958.71,
                    785.015, 958.844,
                    851.354, 970.407,
                    695.442, 1060.86,
                    762.016, 1030.47,
                    831.739, 1061.45,
                    761.925, 1078.05,
                    764.919, 1052.53,
                    1159.96, 1057.15,
                    1095.47, 1027.06,
                    1024.35, 1059.23,
                    1095.76, 1075.26,
                    1095.14, 1049.36,
                    926.643, 1035.63,
                    846.226, 1197.25,
                    816.189, 1250.32,
                    844.54, 1287.81,
                    923.205, 1301.29,
                    1002.7, 1287.33,
                    1030.73, 1250.9,
                    1000.92, 1197.25,
                    924.589, 1142.03,
                    867.101, 1267.19,
                    978.791, 1266.53,
                    781.328, 1413.28,
                    830.316, 1383.29,
                    883.892, 1371.98,
                    921.481, 1379.53,
                    958.83, 1371.89,
                    1011.89, 1382.76,
                    1060.45, 1412.51,
                    1024.72, 1447.3,
                    979.866, 1469.05,
                    919.928, 1476.21,
                    860.431, 1470.09,
                    814.871, 1448.01,
                    851.222, 1424.08,
                    920.017, 1430.29,
                    989.613, 1422.96,
                    990.293, 1402.93,
                    920.629, 1405.27,
                    852.352, 1403.29,
                    923.259, 1242.78,
                    723.668, 1039.43,
                    802.767, 1038.03,
                    798.503, 1071.92,
                    725.562, 1072.98,
                    1133.45, 1035.65,
                    1054.07, 1035.52,
                    1058.52, 1069.49,
                    1131.11, 1069.52};
//    double pos[] = {671.604, 1715.6,
//                    660.222, 1847.79,
//                    674.417, 1982.25,
//                    705.079, 2118.56,
//                    761.766, 2234.15,
//                    839.312, 2330.64,
//                    930.25, 2409.77,
//                    1042.96, 2436.36,
//                    1161.25, 2415.44,
//                    1263.49, 2341.6,
//                    1350.83, 2248.48,
//                    1415.48, 2134.09,
//                    1450.97, 1997.45,
//                    1469.54, 1863.34,
//                    1461.29, 1729.62,
//                    1378.17, 1662.6,
//                    1314.67, 1630.78,
//                    1218.46, 1634.25,
//                    1141.22, 1650.13,
//                    735.658, 1649.16,
//                    794.97, 1620.13,
//                    888.758, 1627.41,
//                    964.262, 1646.43,
//                    788.617, 1746.74,
//                    862.691, 1716.21,
//                    943.068, 1753.61,
//                    861.269, 1770.96,
//                    866.172, 1741.69,
//                    1323.5, 1757.75,
//                    1247.87, 1724.15,
//                    1166.64, 1758.54,
//                    1247.64, 1779.13,
//                    1245.45, 1749.65,
//                    1051.04, 1731.09,
//                    958.165, 1918.51,
//                    923.656, 1977.56,
//                    953.987, 2020.13,
//                    1042.09, 2043.19,
//                    1136.88, 2024.35,
//                    1170.11, 1982.12,
//                    1136, 1922,
//                    1045.28, 1858.43,
//                    977.25, 2002.16,
//                    1109.89, 2004.11,
//                    892.871, 2151.64,
//                    946.238, 2127.47,
//                    1002.05, 2118.96,
//                    1043.14, 2127.94,
//                    1085.08, 2120.75,
//                    1144.41, 2131.74,
//                    1203.5, 2158.63,
//                    1162.15, 2195.24,
//                    1109.72, 2219.08,
//                    1042.84, 2226.07,
//                    978.184, 2215.86,
//                    930.531, 2189.91,
//                    969.856, 2162.88,
//                    1043.99, 2173.41,
//                    1121.12, 2166.57,
//                    1120.26, 2156.57,
//                    1043.36, 2160.08,
//                    969.267, 2153.08,
//                    1040.39, 1980,
//                    819.461, 1724.46,
//                    909.144, 1726.21,
//                    903.87, 1765.06,
//                    820.563, 1762.95,
//                    1291.71, 1734.13,
//                    1201.15, 1732.27,
//                    1205.25, 1771.52,
//                    1289.4, 1772.78};
    //Initialize feature position
    m_featurePos.clear();
    for(int i=0; i<142; i++)
    {
        m_featurePos.push_back(pos[i]);
    }

    //Initalize the rect of face
    m_faceRect.x = 519;
    m_faceRect.y = 755;
    m_faceRect.width = 782;
    m_faceRect.height = 782;

    m_imagePath = "/mnt/sdcard/DCIM/IMG_00000001.jpg";
//    m_imagePath = "/mnt/sdcard/Download/data4.jpg";

    //Initialize image
    m_img = QImage(m_imagePath, "JPEG");
    if(m_img.width() > m_img.height())
    {
        QTransform transform;
        transform.rotate(-90);
        m_img = m_img.transformed(transform);
        m_img.save(m_appFileDirectory+"/oface.jpg");
    }

    m_img = m_img.convertToFormat(QImage::Format_RGB888);
}

void Plugin::meanFilter(Mat &pSrc, int pSX, int pSY, int pEX, int pEY)
{
    qDebug() << "Plugin::meanFilter()";
    Mat tmp = pSrc(Rect(pSX, pSY, pEX-pSX, pEY-pSY)).clone();
    blur(tmp, tmp, Size(3,3));

    QImage img = QImage(tmp.data, tmp.cols, tmp.rows, tmp.step, QImage::Format_RGB888).copy();
    qDebug() << img.save(m_appFileDirectory+"/tmp.png");
}
